EN:
üîπ POST 6 -- REAL ERROR, REAL ENGINEERING

While loading the most granular table (sets), the pipeline failed with a database error. Not a syntax error. Not a missing column. It was a real-world data engineering issue.

The cause:

* Pandas uses NaN
* PostgreSQL expects NULL
* NaN != NULL

Some numeric fields were validly missing (time-based exercises, cardio, RPE), but sending NaN directly to PostgreSQL breaks the load.

The fix wasn‚Äôt a workaround:

* No schema change
* No forced casting
* No "ignoring the error"

The correct solution was:

* Explicitly converting NaN -> None -> NULL inside the ETL
* Preserving data meaning
* Keeping the model strict

After that:

* All 9,542 sets loaded correctly
* Referential integrity preserved
* Pipeline fully idempotent

This is the kind of problem you don‚Äôt see in toy datasets -- and exactly why building with real data matters.


PT:
üîπ POST 6 -- ERRO REAL, ENGENHARIA REAL

Durante a carga da tabela mais granular (sets), o pipeline quebrou com um erro no banco. N√£o era erro de sintaxe. N√£o era coluna faltando. Era um problema real de engenharia de dados.

A causa:

* Pandas trabalha com NaN
* PostgreSQL espera NULL
* NaN != NULL

Alguns campos num√©ricos estavam ausentes de forma v√°lida (exerc√≠cios por tempo, cardio, RPE), mas enviar NaN direto para o banco quebra a carga.

A corre√ß√£o n√£o foi gambiarra:

* Nada de mudar schema
* Nada de for√ßar cast
* Nada de "ignorar erro"

A solu√ß√£o correta foi:

* Converter explicitamente NaN -> None -> NULL no ETL
* Preservar o significado do dado
* Manter o modelo rigoroso

Depois disso:

* Todas as 9.542 s√©ries carregaram corretamente
* Integridade referencial mantida
* Pipeline totalmente idempotente

Esse tipo de problema n√£o aparece em datasets de brinquedo -- e √© exatamente por isso que trabalhar com dados reais importa.